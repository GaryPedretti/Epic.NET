<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 6. SOLID Principles</title><link rel="stylesheet" href="/layout.css" type="text/css" /><link rel="stylesheet" href="/screen.css" type="text/css" /><link rel="stylesheet" href="css/shCore.css" type="text/css" /><link rel="stylesheet" href="css/shCoreDefault.css" type="text/css" /><link rel="stylesheet" href="css/shThemeDefault.css" type="text/css" /><link rel="stylesheet" href="css/documentation.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="manual.html" title="Dominant Domains" /><link rel="up" href="a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="prev" href="observable_entities.html" title="Chapter 5. Observable Entities" /><link rel="next" href="single_mutable_state.html" title="Chapter 7. Single Mutable State" /><meta charset="utf-8" /><link rel="icon" href="/favicon.ico" /><script src="script/shCore.js" type="text/javascript"></script><script src="script/shBrushCSharp.js" type="text/javascript"></script><link rel="alternate" type="application/atom+xml" title="Development log" href="atom.xml" /><!--[if !IE 7]>
    <style type="text/css">
		#wrap {display:table;height:100%}
	</style>
  <![endif]--><!--[if lt IE 8]>
    <style type="text/css">
        #header {padding-top: 9px}
    </xsl:element>
  <![endif]--><!--[if IE 8]>
    <style type="text/css">
		#wrap {width:100%}
	</style>
  <![endif]--><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23846269-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  </script></head><body><div id="wrap"><div id="header"><a href="http://github.com/Shamar/Epic.NET/"><img style="position: absolute; top: 0; left: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub" /></a><a class="title" href="/">Epic</a><span>dominant domains</span></div><div id="main"><div id="content"><div class="chapter" title="Chapter 6. SOLID Principles"><div class="titlepage"><div><div><h2 class="title"><a id="solid_principles"></a>Chapter 6. SOLID Principles</h2></div></div></div><div class="toc"><ul><li><a href="/doc/manual.html" class="toc-title">Table of Contents</a></li><li><span class="section"><a href="solid_principles.html#about_single_responsibility">Single Responsibility</a></span></li><li><span class="section"><a href="solid_principles.html#about_open_closed">Open-Closed</a></span></li><li><span class="section"><a href="solid_principles.html#about_liskov_substitution">Liskov Substitution</a></span></li><li><span class="section"><a href="solid_principles.html#about_dependency_inversion">Dependency Inversion</a></span></li><li><span class="section"><a href="solid_principles.html#about_interface_segregation">Interface Segregation</a></span></li></ul></div><p>We all know the principles introduced by Robert C. Martin in the early 2000s.
They are milestones in the evolution of OOP and they are still valid ten years
later.</p><p>However, when applied to a domain model, they need some small adjustments
based upon the unfortunate experiences of a few experienced developers facing
to their first domain model.</p><div class="caution" title="Caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>We do not pretend to talk out each principle, as Martin’s books are a
must read for developers using Epic.</p></td></tr></table></div><p>We heartily recommend the principles described, as they will increase the
stability of your models, improving their quality even from a design point
of view.</p><div class="section" title="Single Responsibility"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_single_responsibility"></a>Single Responsibility</h2></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>A class should have only <span class="strong"><strong>one</strong></span> reason to change.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">
Robert C. Martin
<em class="citetitle">Agile Software Development, Principles, Patterns, and Practices (2002)</em>
</span></td></tr></table></div><p>In the context of the SRP, Martin defines a responsibility to be "a reason for
change". He states that if you can think of more than one motive for changing a
class, than that class has more than one responsibility.
However, whenever no change actually occur, separating responsibility could
smell of needless complexity.</p><p>In a domain model rightly partitioned in contexts, there are only tree
legitimate reasons for change:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
business evolution,
</li><li class="listitem">
deeper insight,
</li><li class="listitem">
bug fixes.
</li></ul></div><p>Since all profitable enterprises evolve, the models that capture their
processes will need to be updated. This kind of changes can not be anticipated
and they affect almost everything in an application built with Epic. <br />
The good news is that the customer acknowledges about the change he is
asking for and he is willing to pay. <sup>[<a id="id422075" href="#ftn.id422075" class="footnote">5</a>]</sup></p><p>Whenever you get a deeper insight into a domain, you are in a economical
dilemma: should we change the code or not? And why? Just to clarify the
model’s expression through the code? <br />
Finding the right answer to these questions is hard and should be done
carefully. You should consider factors like the complexity of the new model and
of the previous one, the time available, the long term cost of postponing the
refactoring (a cost always undervalued, that slowly increases each day),
the cost of all workarounds that you’ll have to implement without the new
model and so on. <br />
My own, personal, opinion is that most of times the refactoring should be
planned with the customer. If it’s not a trivial task, you should never hide to
the customer the problems emerged with the previous model.</p><p>Finally, as there’s no software without bug, all fixes will force you to modify
the model. This could seem quite obvious, but it has a nasty side effect: you
could introduce new subtle untracked bugs.
Unit tests' code coverage could reduce the risks but can not eliminate them.
<sup>[<a id="id422108" href="#ftn.id422108" class="footnote">6</a>]</sup>
Fortunatly, since no bug should relate to contracts (or it will lead you to a
far more expensive refactoring toward a deeper insight), all the code depending
on the broken component don’t even need to be recompiled. Indeed, one of the
reason that led us to introduce a thin layer of pure interfaces around the
domain model implementation was the evaluation of the deploy’s costs of bug
fixes. With such interfaces, we can minimize the number of layers affected by a
bug in the domain, reducing the system stops and the loss for our customer.</p></div><div class="section" title="Open-Closed"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_open_closed"></a>Open-Closed</h2></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>Software entities (classes, modules, functions, etc.) should be open for
extension, but closed for modification.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">
Robert C. Martin
<em class="citetitle">Agile Software Development, Principles, Patterns, and Practices (2002)</em>
</span></td></tr></table></div></div><div class="section" title="Liskov Substitution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_liskov_substitution"></a>Liskov Substitution</h2></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>Subtypes must be substitutable for their base types.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">
Robert C. Martin
<em class="citetitle">Agile Software Development, Principles, Patterns, and Practices (2002)</em>
</span></td></tr></table></div></div><div class="section" title="Dependency Inversion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_dependency_inversion"></a>Dependency Inversion</h2></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
High-level modules should not depend on low-level modules.
   Both should depend on abstractions.
</li><li class="listitem">
Abstractions should not depend on details.
   Details should depend on abstractions.
</li></ol></div></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">
Robert C. Martin
<em class="citetitle">Agile Software Development, Principles, Patterns, and Practices (2002)</em>
</span></td></tr></table></div></div><div class="section" title="Interface Segregation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_interface_segregation"></a>Interface Segregation</h2></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>Clients should not be forced to depend on methods that they do not use.</p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">
Robert C. Martin
<em class="citetitle">Agile Software Development, Principles, Patterns, and Practices (2002)</em>
</span></td></tr></table></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id422075" href="#id422075" class="simpara">5</a>] </sup>How will be explained into
the third part of the book, in such a case you should consider whether to
write a new bounded context or modify the current one.
The number of production environments running the current code could be a
persuasive argument in one sense or another.</p></div><div class="footnote"><p><sup>[<a id="ftn.id422108" href="#id422108" class="simpara">6</a>] </sup>I think that the domain model implementation should take pride in a
full code coverage (100%). This seems expensive at first, when you are at 97%
and you can’t find a way to test those dirty three lines.
However, a full code coverage will force you to read your code over and over
again, drastically improving the quality of the implementation itself.
The ROI of such kind of revision is often bigger than that of the tests
themselves as safety net.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="observable_entities.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="a_shared_modeling_grammar.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="single_mutable_state.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 5. Observable Entities </td><td width="20%" align="center"><a accesskey="h" href="manual.html">Table of Contents</a></td><td width="40%" align="right" valign="top"> Chapter 7. Single Mutable State</td></tr></table></div></div></div></div><div id="footer"><div class="copyright">Copyright © 2010-2011 Giacomo Tesio</div></div><script type="text/javascript">SyntaxHighlighter.all()</script></body></html>
