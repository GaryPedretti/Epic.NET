<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 1. Bounded Roles</title><link rel="stylesheet" href="/layout.css" type="text/css" /><link rel="stylesheet" href="/screen.css" type="text/css" /><link rel="stylesheet" href="documentation.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="manual.html" title="Dominant Domains" /><link rel="up" href="about_toward_a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="prev" href="about_toward_a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="next" href="about_shared_identifiers.html" title="Chapter 2. Shared Identifiers" /><meta charset="utf-8" /><link rel="icon" href="/favicon.ico" /><link rel="alternate" type="application/atom+xml" title="Development log" href="atom.xml" /><!--[if !IE 7]>
    <style type="text/css">
		#wrap {display:table;height:100%}
	</style>
  <![endif]--><!--[if lt IE 8]>
    <style type="text/css">
        #header {padding-top: 9px}
    </xsl:element>
  <![endif]--><!--[if IE 8]>
    <style type="text/css">
		#wrap {width:100%}
	</style>
  <![endif]--></head><body><div id="wrap"><div id="header"><a href="http://github.com/Shamar/Epic.NET/"><img style="position: absolute; top: 0; left: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub" /></a><div class="title">Epic</div><span>dominant domains</span></div><div id="main"><div id="content"><div class="chapter" title="Chapter 1. Bounded Roles"><div class="titlepage"><div><div><h2 class="title"><a id="about_bounded_roles"></a>Chapter 1. Bounded Roles</h2></div></div></div><div class="toc"><ul><li><a href="/doc/manual.html" class="toc-title">Table of Contents</a></li><li><span class="section"><a href="about_bounded_roles.html#about_know_your_users">Know your users</a></span></li><li><span class="section"><a href="about_bounded_roles.html#about_binding_roles_to_contexts">Binding roles to contexts</a></span></li><li><span class="section"><a href="about_bounded_roles.html#about_a_junction_point">A junction point</a></span></li></ul></div><p>Whenever you have to deal with a large project, you’ll have to
define a set of bounded contexts, each describing a different point of view
upon the same concepts.</p><p>What is an entity in a context will be a value object in another.</p><p>When related to enterprise processes, such contexts will be connected to the
organization chart: different users can access to different contexts, often
with slightly different capabilities.</p><p>Moreover, while you can sell the same domain model to different organizations,
you can’t neither predict nor generalize the organizational structure.
You can make your software configurable, but whenever the access control
rules are complex enough you fall in a customization hell that will erode
the return on investment.</p><p>As an alternative, we decided to model the typical roles of the customer’s
organization, each providing the entry-point to a bounded context.</p><p>This was hard to explain to our stakeholders, since for each new customer
we get, there are a set of modeling tasks to do.
However, as these activities can be easily planned, they managed to value them
as a really cool feature: we can customize the applications we sell to fit the
corporate structure of the customer!</p><div class="section" title="Know your users"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_know_your_users"></a>Know your users</h2></div></div></div><p>All applications have users. This is so evident that it’s often forgot.</p><p>Each day a user log into our application and access a set of functionalities.
He can browse statistical reports and portfolios, he fills profiles of his own
customers, he advises them, he plans gifts for them, he sends their orders to
financial markets and so on.
But he can also access reports about his colleagues, aggregate statistics about
their performances. Some time he can send to them alerts. He can even build a
report forecasting the enterprise’s revenues for the board of directors.</p><p>What he can do depend on the position he plays in the organization.
And you know how complex could be an human organization.
At first it seem a simple hierarchy, a tree of roles, but soon you learn
that assistants must be able to operate for their boss, that private bankers
are not born equals and that exceptions exists… just to make you crazy.</p><p>If you ever thought to model each kind of user, you know what I mean.</p><p>Nevertheless you need to know what each user can do, when and how.
Delegating such logic to the infrastructure is just an illusion: you are
moving the problem elsewhere (often where it’s harder to solve non-trivial
cases).</p></div><div class="section" title="Binding roles to contexts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_binding_roles_to_contexts"></a>Binding roles to contexts</h2></div></div></div><p>The solution we found was to model the roles of customer’s organization after
the domain contexts.</p><p>Each role provides access to a set of repositories, domain services,
responsibility and tools just like any real role in any real enterprise.
We found that roles follow almost exactly the context boundaries of our best
domains, sometimes customized with addictional requirements.</p><p>We were not afraid to write specific code for each customer, confident that a
satisfied customer would have paid more.</p></div><div class="section" title="A junction point"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_a_junction_point"></a>A junction point</h2></div></div></div><p>Roles have proved to be an efficent junction point between the pure domain
model (implemented as plain old C# objects) and the hosting infrastructure.</p><p>Logging, persistence, resource allocations, user locking and so on:
all passes through the users' roles that act as a natural injector for the
infrastructural code.</p><p>For example the repositories can bind the user’s access to specified entities,
according to the fanciest rules that your customer can imagine, the domain
services can be customized to log calls or to cache results and everything you
hate will become easy.</p><p>You just have to deal with angry stakeholders that will tell you: "but we
already did it three months ago!"</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="about_toward_a_shared_modeling_grammar.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="about_toward_a_shared_modeling_grammar.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="about_shared_identifiers.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part I. Toward a shared modeling grammar </td><td width="20%" align="center"><a accesskey="h" href="manual.html">Table of Contents</a></td><td width="40%" align="right" valign="top"> Chapter 2. Shared Identifiers</td></tr></table></div></div></div></div><div id="footer"><div class="copyright">Copyright © 2010-2011 Giacomo Tesio</div></div></body></html>
