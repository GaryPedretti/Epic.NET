[[epic-prelude]]
Epic.Prelude
------------
The Epic.Prelude can be thought of as a preface for your domain model. 
It provides a set of general purpose models distilled from our experience. 

Indeed during some years of domain driven design we faced many different 
domains and we discovered some common concepts in them (most of which are 
rooted in theorethical math). After some trials and errors we got a flexible 
design that is proposed in this module.

NOTE: You could object that while one of the core design targets of Epic is to 
keep the domain model ignorant of the infrastructure, Epic.Prelude 
imposes a dependency from Epic itself. You're right!
You should carefully consider pro and cons of such dependency.
However, since the Epic.Prelude models are actually usefull we decided to 
provide them.

WARNING: From a legal point of view, by referencing Epic.Prelude, your 
domain model will be subjected to the licencing terms with which you obtained 
Epic. In other words, if you obtained Epic under the 
http://www.gnu.org/licenses/agpl-3.0.html[Affero GPLv3], 
your whole domain must be distributed under the terms of such a license. 
Note however that, this is already true for the rest of the application built 
with Epic. mailto:giacomo@tesio.it[Contact the authors] to obtain 
a linking exception if you want to write proprietary code.

Epic itself depends on Prelude's models, so you will have to include such a 
library into the runtime environment of applications using Epic.

Interpreting values
~~~~~~~~~~~~~~~~~~~
Many value objects serves two different purposes: to enforce a set of specific
rules and to express such a rule. From the client point of view we can call
these two connected responsibilities **execution** and **interpretation**.

While this could seem quite abstract, it looks perfectly reasonable when we
looks to that particular value objects that work like mathematical functions.
Specifications, for example, are predicates that can be both executed, to know
whether a candidate satisfy them, or interpreted, translating them into a human
readable sentence or into SQL queries. footnote:[A closer look shows that execution 
is actually a specific kind of interpretation, done by the CLR. Indeed, some stacktraces
from http://msdn.microsoft.com/en-us/library/bb345362[Expression<TDelegate>.Compile]
show that expression tree compilation is done by a visitor producing the executable IL code.]

The need for value objects' interpretation poses a problem to software 
maintenance: how can we stick to the open-closed principle if we have to 
interpret an ever growing number of value objects' types? 

Most of interpretation techniques rely on the Visitor design pattern 
and its underlying mechanism known as "double dispatch". 
However both the http://en.wikipedia.org/wiki/Visitor_pattern[classical] and 
the http://objectmentor.com/resources/articles/visitor.pdf[acyclic] version of
the visitor patterns suffers of a 
http://c2.com/cgi/wiki?VisitorPattern[well known limitation]: whenever you 
want to add a new element to the visited class hierarchy you have to 
change all the visitors.

To address this issue we developed the **composite visitor** pattern that 
actually is just an acyclic visitor that replaces inheritance with composition.

The base interface for visitable objects is the 
http://epic.tesio.it/doc/api/html/T_Epic_IVisitable.htm[IVisitable] interface
that defines the http://epic.tesio.it/doc/api/html/M_Epic_IVisitable_Accept__1.htm[Accept]
method. footnote:[To reduce the effort of implementing the IVisitable interface, 
a http://epic.tesio.it/doc/api/html/T_Epic_VisitableBase.htm[base class] exists. 
Moreover, a set of extension methods is provided for well known class hierarchy 
such as Exceptions, EventArgs and Expressions.] 

The first difference from the classical pattern is that Accept takes a 
http://epic.tesio.it/doc/api/html/T_Epic_IVisitor_1.htm[visitor] and a 
http://epic.tesio.it/doc/api/html/T_Epic_IVisitContext.htm[context for the visit]
decoupling the visitor from its mutable state. footnote:[We want the visitors to
be stateless so that we can initialize each of them only once, at application 
start up, and then use the computation they express in parallel from different 
threads.] 

Moreover, the visitor take controls over it's own cast to the specialized 
visitor type footnote:[We called this technique "managed cast". It consists 
into delegating a cast to the object that you want to cast, so that it has 
control on the casting behaviour according to runtime conditions.] through
the method http://epic.tesio.it/doc/api/html/M_Epic_IVisitor_1_GetVisitor__1.htm[GetVisitor<TExpression>].

Thus, when the visitor is an instance of a class that extends the
http://epic.tesio.it/doc/api/html/T_Epic_CompositeVisitorBase_2.htm[CompositeVisitorBase<TResult, TExpression>]
abstract class, the composition will be able to returns a specialized visitor
that designed to interpret that specific expression.



Specifying qualities
~~~~~~~~~~~~~~~~~~~~

Coming soon.
